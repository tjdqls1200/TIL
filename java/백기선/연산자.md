# 자바 스터디 (3주차)



- 산술 연산자
- 비트 연산자
- 관계 연산자
- 논리 연산자
- instanceof
- assignment(=) operator
- 화살표(->) 연산자
- 3항 연산자
- 연산자 우선 순위
- (optional) Java 13. switch 연산자



### 1. 산술 연산자

산술 연산자는 덧셈(+), 뺄셈(-), 곱(*), 나눗셈(/), 나머지 값(%) 5개가 있으며 두 개의 피연산자를 산술 계산해줍니다. JVM은 기본적으로 32bit 단위로 계산을 하는데 이로 인하여 int형보다 작은 타입의 정수는 int 타입으로 변환 후 연산이 됩니다.



**1) 피연산자 간에 서로 타입이 다를 경우 크기가 더 큰 타입에 맞추어 변환이 된 후에 연산이 이루어집니다.** (피연산자가 int형보다 작을 경우 int형으로 변환 후 연산)

- double > float > long > int(기본 타입)

- int형보다 작은 정수는 전부 int형으로 변환



**2) 산술 결과를 변수에 대입할 경우 피연산자 간 산술을 먼저 하고 결과값을 변수에 대입합니다.**

```java
int num1 = 10;
int num2 = 4;
double result = num1 / num2;

// 두 정수 num1, num2의 나눗셈이 먼저 이루어지고 (10/4 = 2)
// 실수형 변수 result에는 타입 변환(정수 -> 실수)이 되어 (2 -> 2.0)이 저장됩니다.

int num1 = 10;
int num2 = 4;
double result = (double)num1 / num2;

// 먼저 정수형 num1이 실수형으로 강제 타입 변환이 되고
// 피연산자 간 타입이 서로 같지 않기 때문에 크기가 더 큰 double형으로 맞추어집니다.
// 그 다음 연산이 이루어지고 (10.0/4.0 = 2.5) result에는 2.5가 저장됩니다.
```



**3) 리터럴 간의 연산은 타입 변환 없이 해당 타입으로 계산이 이루어집니다.**





### 2. 비트 연산자

비트 연산은 데이터를 bit 단위로 계산하며 0과 1로 표현되는 정수 타입만 비트 연산을 할 수 있습니다. 비트 연산자는 비트 논리 연산자와 비트 이동 연산자로 나뉩니다.



**1) 비트 논리 연산자**

|    **AND 논리곱 (&)**     |          **두 비트 모두 1이면 연산 결과 1**          |
| :-----------------------: | :--------------------------------------------------: |
|    **OR 논리합 (\|)**     |       **두 비트 중 하나만 1이면 연산 결과 1**        |
| **XOR 배타적 논리합 (^)** | **두 비트 중 하나는 1, 하나는 0일 경우 연산 결과 1** |
|   **NOT 논리 부정 (~)**   |                       **보수**                       |



**2) 비트 이동 연산관계 연산자**

| A <**< B**  | **A의 각 비트를 B만큼 왼쪽으로 이동, 빈자리는 0bit로 채움**  |
| :---------: | :----------------------------------------------------------: |
| **A >> B**  | **A의 각 비트를 B만큼 오른쪽으로 이동, 빈자리는 A의 최상위 부호 비트와 같은 값으로 채움** |
| **A >>> B** | **A의 각 비트를 B만큼 오른쪽으로 이동, 빈자리는 0bit로 채움** |







### 3. 관계(비교) 연산자

관계 연산자는 두 피연산자 간의 관계를 비교하는 연산자로 ==(같다), !=(같지 않다), >(크다), >=(크거나 같다) 등의 연산자가 있습니다.

==의 경우 기본 타입을 비교할 경우 값을 비교하지만 String 또는 참조 타입을 비교할 경우 동일한 객체인지를 비교합니다.

그리고 두 피연산자의 타입이 다를 경우 크기가 큰 연산자의 타입에 자동 형변환이 되어 비교를 합니다.







### 4. 논리 연산자

논리 연산자는 boolean 타입의 연산을 수행하며 조건식에서 주로 사용이 됩니다. 논리 연산자는 비트 논리 연산자와 동일하며 피연산자가 boolean 타입이면 논리 연산자, 정수 타입이면 비트 논리 연산자로 사용됩니다. (1 <-> true, 0 <-> false)

그리고 &&, || 연산자의 경우 기본적으로 &, | 연산자와 산출 결과는 같지만 연산 방식에서 피연산자1의 결과에 따라 불필요할 경우 피연산자2의 계산을 생략할 수 있습니다. 그래서 성능적으로 더 유리합니다.







### 5. instanceof

instanceof 는 객체 타입을 확인해주는 연산자입니다. 해당 객체가 형변환이 가능한지의 여부에 따라 boolean형 타입의 결과값을 출력합니다.

```java
//객체 instanceof 클래스

A a = new A();

a instanceof A // true
```







### 6. 대입 연산자 assignment(=) operator

대입 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자인 변수에 저장해주는 연산자입니다. 모든 연산자들 중 가장 낮은 연산 우선 순위이기 때문에 제일 마지막에 수행됩니다. (마지막에 대입이 되기 때문에 데이터 타입에 주의해야 합니다.)







### 7. 화살표(->) 연산자

화살표 연산자(->)는 람다식이라는 표현식에서 매개 변수들을 함수로 전달하는데 사용이 됩니다.

그리고 java 13.switch문에서 break문을 생략하는 대신 사용이 됩니다.







### 8. 삼항 연산자

삼항 연산자는 세 개의 피연산자를 필요로 하는 연산자로 조건식의 결과에 따라 피연산자2 또는 피연산자3의 값 또는 연산식을 출력합니다. 피연산자2, 3에 삼항 연산식을 또 대입하여 다중 if문식으로 사용할 수도 있고 매개 변수에 상황에 따라 값을 대입해야 하는 경우에도 응용할 수 있습니다.

**조건식(피연산자1) ? true(피연산자2) : false(피연산자3)**

**조건식 ? ture : (조건식 ? true : false)**







### 9. 연산자 우선 순위

1) 피연산자의 개수에 따른 연산 우선 순위는  **단항 > 이항 > 삼항**의 우선 순위를 가집니다.

2) 연산자 우선 순위는 **산술 > 쉬프트 > 비교 > 논리 > 조건(?, :) > 대입**의 우선 순위를 가집니다.

3) 연산자의 우선 순위가 같을 경우에는 왼쪽에서 오른쪽으로 연산을 합니다.

4) 연산의 방향은 기본적으로 왼쪽에서 오른쪽으로 진행하며 증감(++, --), 부호(+, -), 대입(=, +=, ..), 비트(~), 논리(!)의 경우에만 반대 방향으로 연산을 합니다. 







### 10. (optional) java 13.switch 연산자

기존의 switch 식에서 yield 라는 키워드로 결과값을 간편하게 리턴할 수 있습니다.

case에 따른 결과값을 따로 담을 변수를 선언할 필요가 없고 break를 생략해도 되는 등 코드가 간결해지는 장점이 있습니다.

그리고 -> 연산자를 이용하여 break문을 생략하거나 case 문이 한 문장일 경우 yield를 생략하고 바로 결과값을 리턴할 수 있는 등의 코드가 간결해지는 장점이 있습니다.







**참고)**

이것이 자바다.

[https://yadon079.github.io/2020/java%20study%20halle/week-03](https://yadon079.github.io/2020/java study halle/week-03)

http://www.tcpschool.com/java/java_lambda_concept

[https://blog.baesangwoo.dev/entry/Live-Study-3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-%EC%97%B0%EC%82%B0%EC%9E%90](https://blog.baesangwoo.dev/entry/Live-Study-3주차-과제-연산자)

