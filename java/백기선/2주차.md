# [Java] 백기선 자바 스터디 2주차



# 자바 데이터 타입, 변수 그리고 배열

- #### 프리미티브 타입 종류와 값의 범위 그리고 기본 값

- #### 프리미티브 타입과 레퍼런스 타입

- #### 리터럴

- #### 변수 선언 및 초기화하는 방법

- #### 변수의 스코프와 라이프타임

- #### 타입 변환, 캐스팅 그리고 타입 프로모션

- #### 1차 및 2차 배열 선언하기

- #### 타입 추론, var





### 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값



프리미티브 타입은 프로그래밍 언어가 제공하는 기본적인 자료형 중 하나 자바에서의 프리미티브 타입은 다음과 같습니다.

![image-20210102194724324](/Users/sungblee/Library/Application Support/typora-user-images/image-20210102194724324.png)

[출처 : https://gbsb.tistory.com/6]



### 2. 프리미티브 타입과 레퍼런스 타입



자바의 데이터 타입은 크게 프리미티브 타입과 레퍼런스 타입으로 분류합니다. **프리미티브(기본) 타입**은 논리, 정수, 실수, 문자 리터럴의 **값을 변수에 직접 저장하는 기본적인 데이터 타입**을 말합니다. 

레퍼런스 타입도 프리미티브 타입과 마찬가지로 변수에 값을 저장하는 데이터 타입이지만 직접적으로 값을 저장하는 프리미티브 타입과 달리 **레퍼런스(참조) 타입**은 배열, 클래스, 인터페이스 등 힙영역에 존재하는 **객체의 메모리 주소값을 저장**합니다. 



### 3. 상수와 리터럴



리터럴은 일반적으로 수학에서의 상수(변하지 않는 불변량)의 개념과 같지만 프로그래밍에서는 상수와 리터럴로 구분하여 사용합니다. 변수는 할당된 값을 얼마든지 바꿀 수 있는데 이러한 변수를 상수로 선언하면 값을 변경할 수가 없습니다. 

자바에서는 final 키워드를 붙여 상수로 선언할 수 있으며 값이 변하는 것을 원치 않거나 해당 값의 의미를 좀 더 명확하게 전달하기 위해 사용됩니다. 정확히는 final로 선언된 변수는 무조건 상수라기보다 값이 한번만 할당될 수 있음을 의미합니다.

```java
public static final double PI = 3.14;	
```

위와 같이 프로그래밍에서는 변경할 수 없는 변수를 상수라고 표현하고 관례상 상수명은 대문자로 표기합니다.

그리고 숫자 1이나 문자 'a' 와 같이 변하지 않는 데이터 자체를 상수 대신 리터럴이라고 표현합니다.

```java
final 상수명 = 리터럴값;
```



### 4. 변수 선언 및 초기화하는 방법



자바에서는 변수를 선언할 때 일반적으로 다음과 같이 선언을 해줍니다. 

```java
// [데이터 타입] [변수명]
int number;
char alphabet;
int a, b;
```



변수를 초기화하는 방법은 **명시적 초기화와 생성자 초기화, 블록 초기화(static 블록, 인스턴스 블록) 방법**이 있습니다.



**1) 명시적 초기화**

가장 일반적으로 변수를 초기화하는 방법으로 **변수를 선언하고 값을 바로 할당**해주는 초기화 방법입니다.

```java
// 선언과 동시에 초기화
int num1 = 1;

// 선언을 한 뒤에 초기화
int num2;
num2 = 2;

// 두 개의 변수를 아래와 같이 초기화하는 경우 num2에만 값이 할당됩니다.
int num1, num2 = 1;
// 올바른 방법
int num1 = 1, num2 = 1;
```



**2) 생성자 초기화**

생성자 초기화는 **객체를 생성함과 동시에 필드를 초기화**하는 방법입니다. 객체마다 고유한 값을 가지는 경우 주로 생성자를 통하여 초기화를 해줍니다.

```java
// 이름과 나이는 학생마다 가지고 있는 고유의 정보이기 때문에 인스턴스 변수는 선언만 하고 값은 생성자를 통해 할당합니다.

class Student {
    String  name;
    int     age;

  	// 인스턴스 변수명과 매개 변수명이 같을 경우 this 키워드를 사용하여 객체 자신의 인스턴스를 참조할 수 있습니다.
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class StudentData {
    public static void main(String[] args) {
        // new 연산자를 사용하여 참조 변수 lee를 생성함과 동시에 생성자에 매개값을 넘겨주어 초기화를 해줍니다.
        Student lee = new Student("이자바", 17);
        System.out.println("이름 : " + lee.name + " 나이 : " + lee.age);
    }
}
```



**3) 블록 초기화**

클래스 내부에서 필드의 초기화 용도로 사용되는 블록 초기화는 **인스턴스 블록과 static 블록** 두 가지 방법이 있습니다. 중괄호({})로 묶어 사용하며 static 블록은 중괄호 앞에 static을 붙이고 인스턴스 블록은 중괄호만 사용하여 선언합니다.

```java
// 인스턴스 블록
{
  
}

// static 블록
static {
  
}
```

**인스턴스 블록**은 객체가 생성될 때마다 실행되며 여러 생성자에서 중복되는 코드를 인스턴스 블록으로 묶어서 코드 중복을 줄일 수 있습니다. 

**static 블록**은 클래스가 메모리에 로드될 때 한번만 실행되며 **클래스 변수의 초기화 목적**으로 사용합니다.





- #### 변수의 스코프와 라이프타임

- #### 타입 변환, 캐스팅 그리고 타입 프로모션

- #### 1차 및 2차 배열 선언하기

- #### 타입 추론, var



### 5. 변수의 스코프와 라이프타임



변수는 선언되는 위치에 따라 사용 가능한 범위와 소멸되는 시점이 다릅니다. 일반적으로 **변수는 해당 변수가 선언된 블럭 내에서만 사용(변수의 스코프)** 할 수 있습니다. 필드부에 선언된 변수는 클래스 전체에서 사용이 가능하고 메소드 내에서 선언된 변수는 메소드 블럭 내에서만 사용할 수 있습니다.







#### 변수 선언 위치에 따른 분류

**1) 필드 변수**



먼저 필드 변수는 클래스 내 필드 위치에 선언되는 변수로 클래스 변수(=스태틱 변수) 와 인스턴스 변수로 나뉘게 됩니다.

**클래스 변수**는 static 키워드를 붙여 선언을 하며 변수를 static(정적)으로 선언하면 **프로그램 실행 시 클래스가 로드 되면서 static 영역에 저장**이 됩니다. static 영역에 할당 된 메모리는 모든 객체가 메모리를 공유하며 **프로그램이 종료될 때까지 소멸되지 않습니다.** 그리고 인스턴스 생성 시에 heap 영역에 할당되는 인스턴스 변수와 달리 static 영역에 할당이 되기 때문에 객체의 생성 없이도 사용할 수 있습니다. 객체가 아닌 클래스에 고정된 변수라서 클래스 변수라고 부르며 주로 객체들이 공통적으로 가지는 값일 경우 static으로 선언을 합니다.

**인스턴스 변수**는 **인스턴스 생성시 heap 영역에 생성**이 되며 인스턴스에 고정되기 때문에 인스턴스 변수라고 부릅니다. 인스턴스가 고유한 값을 가지는 정보를 인스턴스 변수로 선언하며 **인스턴스가 소멸될 때 같이 소멸**됩니다.







**2) 지역 변수**



**지역 변수**는 메소드 내에서 선언하여 사용하며 **메소드 실행 시 stack 영역에 할당이** 되고 **메소드 블럭이 종료되면 소멸**이 됩니다. 전역 변수(=클래스 변수)는 프로그램이 종료될 때까지 소멸되지 않기 때문에 신중하게 사용하는 것이 좋지만 지역 변수는 메소드 종료시 바로 소멸이 되기 때문에 변수 선언에 자유로운 장점이 있습니다. 