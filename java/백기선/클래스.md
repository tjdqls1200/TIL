# 클래스



### 목표.

- **클래스 정의하는 방법**
- **객체 만드는 방법 (new 키워드 이해하기)**
- **필드, 메소드, 생성자 정의하는 방법**
- **this 키워드 이해하기**



### 1. 클래스란?

객체 지향 프로그래밍(Object Oriented Programming)이란 각각의 필드(속성)과 메소드(동작)을 가지고 있는 객체들을 설계하여 만들고, 이를 조립해서 프로그램을 만드는 기법을 말한다. 그리고 이러한 **객체의 설계도**를 클래스라고 한다.



### 2. 클래스 정의하는 방법

클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있고 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(Instance)라고 한다.

- 소스 파일과 클래스의 이름은 같아야하며 일반적으로 한 파일에 하나의 클래스만 정의한다.
- 하나의 소스 파일에 두 개 이상의 클래스를 선언할 경우 접근 제한자는 파일명과 같은 클래스에만 붙여준다. 
- 두 개 이상의 클래스가 선언된 소스 파일을 컴파일해도 바이트코드(.class) 파일은 클래스를 선언한 개수만큼 생긴다.
- 소스 파일은 클래스가 선언된 파일일뿐 클래스 자체는 아님

```java
// Car.java
public class Car {
  // 필드와 메소드
}
```

클래스는 라이브러리(API : Application Program InterPace)와 실행용으로 나뉜다. 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계되고 프로그램 내 하나만 생성하는 실행 클래스는 프로그램의 실행 진입전인 main() 메소드를 제공하는 역할을 한다.



### 3. 객체 만드는 방법

클래스로 객체를 만들기 위해서는 new 연산자를 사용하면 된다.

new 연산자는 객체를 heap 영역에 생성하고, 객체의 주소를 리턴해준다. 

주소를 참조 타입인 클래스 변수(stack 영역에 생성)에 저장하고 클래스 변수를 통해 접근

```java
// 클래스 클래스변수 = new 생성자()
Car myCar = new Car();
```





### 4. 필드, 메소드, 생성자 정의하는 방법

#### 필드

**필드(객체 속성)**는 **객체의 고유 데이터, 상태 정보가 저장되는 곳**으로 일반적으로 변수를 선언하는 것과 비슷하지만 변수와는 차이가 있다.

- 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 종료시 같이 소멸
- 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재



#### 메소드

메소드는 객체의 동작에 해당하는 실행 {} 블록으로 메소드 호출 시 {} 블록에 있는 모든 코드들이 실행된다. 

- 메소드 내에서 선언되는 변수는 지역 변수로 메소드 실행 시 스택 영역에 할당되며 메소드가 종료 시 소멸된다.
- 클래스 외부에서 메소드를 호출할 경우 클래스 객체를 먼저 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야 한다. (메소드를 static으로 선언한 경우 객체 생성 없이 클래스로 바로 호출할 수 있다.)



#### 생성자

생성자는 new 연산자로 호출되는 중괄호 {} 블럭으로 객체 생성 시 초기화 역할을 담당한다.

- 생성자 이름은 클래스명과 같아야 한다.

- 생성자는 return값이 없다.

- 일반적으로 선언 시 매개변수를 전달하여 객체 초기화를 해준다.

- 하나의 클래스에 여러 개의 생성자를 만들 수 있다. (생성자 오버로딩 : 매개 변수를 달리하는 생성자를 여러 개 선언하는 것)

- 생성자에서 다른 생성자를 호출하여 초기화를 해줄 수 있다. (생성자 간 중복 코드 제거, 역할 분담)

- 생성자도 메서드에 속하기 때문에 return값이 없는 void를 붙여야하지만, 모든 생성자가 return 값이 없기 때문에 생략한 것

- 생성자 선언 생략시 컴파일러가 기본 생성자를 바이트코드에 자동으로 추가한다.

- 생성자가 명시적으로 선언되어 있는 경우 반드시 생성자를 호출해서 객체를 생성해야 한다.

  

```java
public class Car {
  // 필드
  String model;
  String color;
  int speed;
  
  // 생성자
  Car() {
    
  }
  
  // 생성자 오버로딩
  Car (String model) {
    this(model, white, 0); //this() 호출
  }
  
  Car (String model, String color, int speed) {
    this.model = model;
    this.color = color;
    this.speed = speed;
  }
  
  // 메소드
  void presentSpeed() {
    System.out.println("현재 속도는 " + this.speed + "입니다.");
  }
}
```



### 5. this 키워드 이해하기

this 는 객체 자신을 참조해주는 키워드다.

그리고 다른 생성자를 호출해주는 방법으로도 this() 키워드를 사용할 수 있다.

여러 생성자가 존재할 때 코드 중복을 제거하기 위해 초기화를 담당하는 생성자를 선언하고 다른 생성자에서는 초기화 생성자를 호출하는 방식으로 this() 를 사용한다.

이 경우 this()는 생성자의 첫줄에 위치해야한다.



### 6. 정적(static)과 final

정적 멤버는 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 객체가 아닌 클래스에 소속된 멤버기 때문에 클래스 멤버라고도 한다.

static 키워드를 통해 정적 멤버로 선언할 수 있으며 클래스 로더가 클래스(바이트코드)를 읽어서 메소드 메모리 영역에 적재할 때 클래스 별로 로드가 되기 때문에 객체의 생성 없이 사용할 수 있다. (객체로도 접근할 수 있지만 클래스 이름으로 접근하는 것이 좋음)

정적 필드를 위한 초기화 방법은 정적 블록을 사용, 정적 블록은 클래스가 메모리에 로딩될 때 실행이 된다. 

```java
public class Car {
  static int speed;
  
  static {
    // 정적 블록
    // 인스턴스 필드,메소드, this 키워드 사용 불가 (사용하려면 객체 생성 후 참조 변수 접근)
	}
}
```



final 필드는 한번 값을 저장하면 프로그램 실행 도중에 수정할 수 없다.

final 필드의 초기값은 필드 선언 시 또는 생성자에서 줄 수 있다.

자바에서 상수는 static과 final을 같이 사용하여 선언할 수 있다. 상수는 객체마다 저장할 필요가 없는 공용성과 여러 값으로 초기화 될 수 없어야된다. 그래서 static final로 선언해서 객체 생성 없이 불변의 값으로 사용할 수 있다..